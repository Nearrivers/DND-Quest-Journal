// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.24.0
// source: objectives.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const activateObjective = `-- name: ActivateObjective :execresult
UPDATE objectives SET is_active = true
WHERE id = ?
`

func (q *Queries) ActivateObjective(ctx context.Context, id int32) (sql.Result, error) {
	return q.db.ExecContext(ctx, activateObjective, id)
}

const createObjective = `-- name: CreateObjective :execresult
INSERT INTO objectives (created_at, updated_at, name, description, number, quest_id)
VALUES (?, ?, ?, ?, ?, ?)
`

type CreateObjectiveParams struct {
	CreatedAt   time.Time
	UpdatedAt   time.Time
	Name        string
	Description string
	Number      int32
	QuestID     int32
}

func (q *Queries) CreateObjective(ctx context.Context, arg CreateObjectiveParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, createObjective,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Name,
		arg.Description,
		arg.Number,
		arg.QuestID,
	)
}

const finishObjective = `-- name: FinishObjective :execresult
UPDATE objectives SET is_complete = true
WHERE id = ?
`

func (q *Queries) FinishObjective(ctx context.Context, id int32) (sql.Result, error) {
	return q.db.ExecContext(ctx, finishObjective, id)
}

const getAllQuestActiveObjectives = `-- name: GetAllQuestActiveObjectives :many
SELECT id, created_at, updated_at, name, description, is_active, is_complete, number, quest_id from objectives
WHERE quest_id = ? AND is_active = true
ORDER BY number
`

func (q *Queries) GetAllQuestActiveObjectives(ctx context.Context, questID int32) ([]Objective, error) {
	rows, err := q.db.QueryContext(ctx, getAllQuestActiveObjectives, questID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Objective
	for rows.Next() {
		var i Objective
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.IsComplete,
			&i.Number,
			&i.QuestID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllQuestDoneObjectives = `-- name: GetAllQuestDoneObjectives :many
SELECT id, created_at, updated_at, name, description, is_active, is_complete, number, quest_id from objectives
WHERE quest_id = ? AND is_complete = true
ORDER BY number
`

func (q *Queries) GetAllQuestDoneObjectives(ctx context.Context, questID int32) ([]Objective, error) {
	rows, err := q.db.QueryContext(ctx, getAllQuestDoneObjectives, questID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Objective
	for rows.Next() {
		var i Objective
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.IsComplete,
			&i.Number,
			&i.QuestID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllQuestObjectives = `-- name: GetAllQuestObjectives :many
SELECT id, created_at, updated_at, name, description, is_active, is_complete, number, quest_id from objectives
WHERE quest_id = ?
ORDER BY number
`

func (q *Queries) GetAllQuestObjectives(ctx context.Context, questID int32) ([]Objective, error) {
	rows, err := q.db.QueryContext(ctx, getAllQuestObjectives, questID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Objective
	for rows.Next() {
		var i Objective
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Name,
			&i.Description,
			&i.IsActive,
			&i.IsComplete,
			&i.Number,
			&i.QuestID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOneObjective = `-- name: GetOneObjective :one
SELECT id, created_at, updated_at, name, description, is_active, is_complete, number, quest_id FROM objectives
WHERE id = ?
ORDER BY number
LIMIT 1
`

func (q *Queries) GetOneObjective(ctx context.Context, id int32) (Objective, error) {
	row := q.db.QueryRowContext(ctx, getOneObjective, id)
	var i Objective
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Name,
		&i.Description,
		&i.IsActive,
		&i.IsComplete,
		&i.Number,
		&i.QuestID,
	)
	return i, err
}

const reorderObjective = `-- name: ReorderObjective :execresult
UPDATE objectives SET number = ?
WHERE id = ?
`

type ReorderObjectiveParams struct {
	Number int32
	ID     int32
}

func (q *Queries) ReorderObjective(ctx context.Context, arg ReorderObjectiveParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, reorderObjective, arg.Number, arg.ID)
}

const updateObjective = `-- name: UpdateObjective :execresult
UPDATE objectives SET name = ?, description = ?, updated_at = ?
WHERE id = ?
`

type UpdateObjectiveParams struct {
	Name        string
	Description string
	UpdatedAt   time.Time
	ID          int32
}

func (q *Queries) UpdateObjective(ctx context.Context, arg UpdateObjectiveParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, updateObjective,
		arg.Name,
		arg.Description,
		arg.UpdatedAt,
		arg.ID,
	)
}
